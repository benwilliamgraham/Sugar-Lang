<h1>Sugar in 15 Minutes</h1>
<hr>
Get an overview of how Sugar works, as well as how to use it effectively
<br><br>

<h2>Setup</h2><hr><pre><code class="language-sugar">
`To be finished later`

</code></pre><br><br>

<h2>"Hello, Sugar"</h2><hr><pre><code class="language-sugar">
`Run the Following Program to ensure that sugar is working:`
"Hello, Sugar" -> write

</code></pre><br><br>

<h2>Comments</h2><hr><pre><code class="language-sugar">
`This is a comment`

`Comments can extend
across multiple lines`

`Comments are ignored by the compiler even if they are valid code`

</code></pre><br><br>

<h2>Variables</h2><hr><pre><code class="language-sugar">
`Everything is made up of three things in Sugar:
  -  Variables
  -  Functions
  -  Objects

We'll start with the most basic of them, variables

Variables are a way to store many forms of data.

Sugar is what is known as a strongly-typed language
This means that a variable has a non-changing type
For example:`

a := 10 `'a' is set to an Int (integer) value

Integers are any whole number`

b := "Test" `'b' is set to an Array of Characters

strings are fixed lists of characters (letters, numbers, symbols)`

c := true `'c' is set to a Boolean value

boolean values are either 'true' or 'false'
This will become important later when you learn control flow`

`Variables can be changed as long as they keep thier original type`

a := 11 `changes the value of 'a' to 11`

`However variables cannot be chaged to a different type`

a := "Test 2" `Results in a compiler error`

`The names of variables, and for that matter function and objects too, all
follow the same naming pattern:

The first character must be a letter (lower or upper) or _
The following characters can be any letter, number, or _
`

</code></pre><br><br>

<h2>Forcing Types</h2><hr><pre><code class="language-sugar">
`You might have noticed that it doesn't say anywhere in the code what types all
of these variables have been

This is because the compiler can figure all of that out for you most of the time

However, there are cases in which you'll want to tell the compiler to treat a
variable as a certain type, for example when defining the precision of a number

Fortunately, Sugar provides you with a way to do this:`

a : Int := 10 `a will be an integer`

b : Float := 10 `b, despite looking like an integer, will be evaluated as a
floating-point number

floating point numbers are any real number, for example 7.06`

`However, you cannot always for a type conversion

This is the case for unrelated types`

c : Int := "Hello" `Will result in a compiler error`

</code></pre><br><br>

<h2>Standard Types</h2><hr><pre><code class="language-sugar">
`Sugar includes a set of defualt types, as well as being compatible with
all C++ types

Sugar uses the following:
  -  Boolean       |  1-bit 'true' or 'false'

  -  Char          |  8-bit character

  -  Int           |  32-bit integer
     Int8          |  8-bit integer
     Int16         |  16-bit integer
     Int32         |  32-bit integer
     Int64         |  64-bit integer

  -  Who           |  32-bit whole-number
     Who8          |  8-bit whole-number
     Who16         |  16-bit whole-number
     Who32         |  32-bit whole-number
     Who64         |  64-bit whole-number

  -  Float         |  64-bit floating-point number
  -  Float32       |  32-bit floating-point
  -  Float64       |  64-bit floating-point number

By default (we'll get into how to change it later), it will assign the following:`

a := 10 `Int`

b := "z" `Char`

c := "abc" `Array`

d := true `Boolean`

e := 1.23423 `Float`

</code></pre><br><br>

<h2>Operators</h2><hr><pre><code class="language-sugar">
`Now on to the most ubiquitous kind of function: operators

Operators are symbols that represent changes that can be done to variables

For example, '+', '-', '*', and '/' are all operators

The value stored in a variable can be set to something else using operators
For example:`

a := 30 - 10 `The value of 'a' is equal to 20`

b := "Sugar" + "Lang" `The value of 'b' is equal to "SugarLang"`

`Operators can also be used with variable arguments`

c := a / a `The value of 'c' is equal to 'a' (20) / 'a' (20), which equals 1`

`And can be a mix of variables and constants`

d := a ^ 2 `The value of 'd' is equal to 'a' (20) squared, which equals 400`

`Although they can be used to modify statement values, operators do not effect
the variables they modify`

d := a + c `The '+' operator does not effect the value stored in 'a' and 'b'`

`There are two kinds of operators: unary and binary

Unary come before the variable they modify`

a := -c `'a' is equal to - 'c' (1), which equals -1`

`Binary come in between the two variables it modifies`

c := c + d `'c' is equal to 'c' (1) + 'd' (400), which equals 401`

`Sugar does not follow the standard order of operations
Instead it does everything in the following order:
  -  Unary Operators
  -  Binary Operators
  -  Assignment

Also, Sugar comes with several standard operators:`
&a `reference`
*a `dereference`
-a `negate`
+a `value of`
~a `bitwise complement`

a ^ b `explonent`
a ;/ b `root`

a * b `multiplication`
a / b `division`
a // b `integer division`
a % b `modulus`

a + b `addition`
a - b `subtraction`

a << b `left bitwise shift`
a >> b `right bitwise shift`

a < b `less than`
a > b `greater than`
a <= b `less than or equal to`
a >= b `greater than or equal to`
a = b `equals`
a != b `not equal to`
a <=> b `comparitor`

a & b `bitwise and`
a | b `bitwise or`
a >< b `bitwise xor`

</code></pre><br><br>

<h2>Functions</h2><hr><pre><code class="language-sugar">
`Standard functions are similar to operators:`

a := f(20) `'a' is equal to the value of f(20)`

`Functions can be used in conjunction with variables`

b := g(a)

`And with operators`

c := h(a + 10) + b

</code></pre><br><br>

<h2>Defining Functions</h2><hr><pre><code class="language-sugar">
`All functions can be defined`

f(x) :=
  x := x + 10
  return x

`There are several things that should be noticed about this:

One of the most important things to notice is the indentation
The tab before the two lines following the definition denotes function ownership

Anything that is indented following a definition is interpreted as a part of
said definition, similar to languages such as Python and Haskell

Also, note that the return statement is the last thing that will happen in the
function, and that any code following the return statement will not execute

Functions, however, do not need a return statement and will return 'void' if
not provided with one

Like variables, the return type of a function, as well as the parameter types
can be specified:`

int_multiply(x : Float, y : Float) : Int :=
  return x * y

`Despite the two parameters being floats, 'int_multiply' will return an 'int'
as specified

Custom operators can also be defined like functions:`

(a : Int) #^% (b : Int) :=
  return a + b ^ 3

`Bonus, figure out what` 10 #^% 34 `will return`

</code></pre><br><br>

<h2>Overloading</h2><hr><pre><code class="language-sugar">
`Overloading`

</code></pre><br><br>

<h2>Control Flow</h2><hr><pre><code class="language-sugar">
`Control Flow`

</code></pre><br><br>

<h2>The Core Library</h2><hr><pre><code class="language-sugar">
`Core`

</code></pre><br><br>

<h2>"Hello, Sugar" Revisited</h2><hr><pre><code class="language-sugar">
`Hello, Sugar`

</code></pre><br><br>

<h2>File Importing</h2><hr><pre><code class="language-sugar">
`File Importing`

</code></pre><br><br>

<h2>C++ Library Support</h2><hr><pre><code class="language-sugar">
`C++`

</code></pre><br><br>

<h2>More Resources</h2><hr><pre><code class="language-sugar">
`More`

</code></pre><br><br>

<script>Prism.highlightAll();</script>
